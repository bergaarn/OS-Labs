#include <stdio.h> // I/O
#include <stdlib.h>
#include <pthread.h> // POSIX threads
#include <unistd.h> // sleep function
#include <time.h> // srand(time(NULL))

#define NUMBER_OF_PROFESSORS 5
pthread_mutex_t chopsticks[NUMBER_OF_PROFESSORS];
const char* names[NUMBER_OF_PROFESSORS] = 
{
    "Tanenbaum",
    "Bos",
    "Lamport",
    "Stallings",
    "Silberschatz"
};

// Utility Function to generate random time to sleep between min and max span
int generateSleepTime(int min, int max)
{
    // Generate random value from min to max, adding min to get the correct span
    int sleepTime = min + rand() % (max - min + 1);
    return sleepTime;
}

// Professor thread 
void* startDining(void* arg) 
{
    int id; // id for professor
    int left; // Chopstick left of the professor with the same id number as professor
    int right; // Chopstick right of the professor which is left chopstick + 1 as id

    left = id = *(int*)arg; // Type cast to int pointer, dereference to get integer then assign to both id and left
    right = (left + 1) % NUMBER_OF_PROFESSORS; // assign right chopstick based on left + 1 then wrap back around
    
    while (1) 
    {
        // Random sleep time generated by utility function
        int sleepTime = 0;
        
        // Avoid deadlock by breaking the Circular Wait condition 
        // by letting the last professor pick up his right chopstick before the left
        if (id == NUMBER_OF_PROFESSORS-1)
        {
            // Think before attempting to pick up right chopstick
            sleepTime = generateSleepTime(1, 5);
            printf("%s: Thinking for %d seconds before attempting to pick up right chopstick\n", names[id], sleepTime);
            sleep(sleepTime);

            // Attempt to pick up right chopstick (same id+1 as the professor)
            printf("%s: Attempting to pick up right chopstick\n", names[id]);
            pthread_mutex_lock(&chopsticks[right]);
            printf("%s: Succesfully picked up right chopstick\n", names[id]);
            
             // Thinking between 2-8 seconds before attempting to pick up left chopstick
            sleepTime = generateSleepTime(2, 8);
            printf("%s: Thinking for %d seconds before attempting to pick up left chopstick\n", names[id], sleepTime);
            sleep(sleepTime);

            // Attempt to pick up left chopstick (same id as the professor)
            printf("%s: Attempting to pick up left chopstick\n", names[id]);
            pthread_mutex_lock(&chopsticks[left]);
            printf("%s: Succesfully picked up left chopstick\n", names[id]);
        }
        else 
        {
            // Think before attempting to pick up the left chopstick
            sleepTime = generateSleepTime(1, 5);
            printf("%s: Thinking for %d seconds before attempting to pick up left chopstick\n", names[id], sleepTime);
            sleep(sleepTime);

            // Attempt to pick up left chopstick (same id as the professor)
            printf("%s: Attempting to pick up left chopstick\n", names[id]);
            pthread_mutex_lock(&chopsticks[left]);
            printf("%s: Succesfully picked up left chopstick\n", names[id]);

            // Think before attempting to pick up right chopstick
            sleepTime = generateSleepTime(2, 8);
            printf("%s: Thinking for %d seconds before attempting to pick up right chopstick\n", names[id], sleepTime);
            sleep(sleepTime);

            // Attempt to pick up right chopstick (same id+1 as the professor)
            printf("%s: Attempting to pick up right chopstick\n", names[id]);
            pthread_mutex_lock(&chopsticks[right]);
            printf("%s: Succesfully picked up right chopstick\n", names[id]);
        }

        // Eating
        sleepTime = generateSleepTime(5, 10);
        printf("%s: Eating for %d seconds\n", names[id], sleepTime);
        sleep(sleepTime);

        // Put down chopsticks
        pthread_mutex_unlock(&chopsticks[left]);
        pthread_mutex_unlock(&chopsticks[right]);
        printf("%s: Stopped eating and putting down both chopsticks\n", names[id]);
    }
    return NULL;
}

int main(int argc, char** argv)
{
    // Create Threads Array
    pthread_t professorThreads[NUMBER_OF_PROFESSORS];
    int professorID[NUMBER_OF_PROFESSORS];

    // Random seed generator once
    srand(time(NULL));

    // Initialize chopsticks resources
    for (int i = 0; i < NUMBER_OF_PROFESSORS; i++)
    {
        pthread_mutex_init(&chopsticks[i], NULL);
    }
        
    // Create professor threads
    for (int i = 0; i < NUMBER_OF_PROFESSORS; i++)
    {
        professorID[i] = i;
        pthread_create(&professorThreads[i], NULL, startDining, &professorID[i]);
    }

    // Wait for professor threads to return
    for (int i = 0; i < NUMBER_OF_PROFESSORS; i++)
    {
        pthread_join(professorThreads[i], NULL);
    }
        
    // Destroy all chopsticks resources
    for (int i = 0; i < NUMBER_OF_PROFESSORS; i++)
    {
        pthread_mutex_destroy(&chopsticks[i]);

    }
        
    return 0;
}